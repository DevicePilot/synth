devices = []

DEFAULT_BATTERY_LIFE_S = sim.minutes(5)  # For interactive process demo

GOOD_RSSI = -50.0
BAD_RSSI = -120.0

def num_devices():
    global devices
    n = len(devices)
    return n

def external_event(params):
    # Accept events from outside world
    # (these have already been synchronised via the event queue so we don't need to worry about thread-safety here)
    global devices
    body = params["body"]
    try:
        logging.info("external Event received: " + str(params))
        for d in devices:
            if d.properties["$id"] == body["deviceId"]:
                arg = None
                if "arg" in body:
                    arg = body["arg"]
                d.external_event(body["eventName"], arg)
                return
        e = "No such devices"  # + str(deviceID) + " for incoming event " + str(eventName)
        log_string(e)
    except Exception as e:
        log_string("Error processing external event")
        logging.error("Error processing externalEvent: " + str(e))
        logging.error(traceback.format_exc())


class Device:
    def __init__(self, props):
        self.properties = props
        devices.append(self)

        self.commsReliability = 1.0  # Either a fraction, or a string containing a specification of the trajectory
        self.commsUpDownPeriod = synth.simulation.sim.days(1)
        self.commsOK = True
        self.do_comms(self.properties)

    def external_event(self, event_name, arg):
        s = "Processing external event " + event_name + " for devices " + str(self.properties["$id"])
        log_string(s)
        if event_name == "replaceBattery":
            self.set_property("battery", 100)
            self.start_ticks()

        # All other commands require devices to be functional!
        if self.get_property("battery") <= 0:
            log_string("...ignored because battery flat")
            return
        if not self.commsOK:
            log_string("...ignored because comms down")
            return

        if event_name == "upgradeFirmware":
            self.set_property("firmware", arg)
        if event_name == "factoryReset":
            self.set_property("firmware", self.get_property("factoryFirmware"))

    def set_comms_reliability(self, up_down_period=synth.simulation.sim.days(1), reliability=1.0):
        self.commsUpDownPeriod = up_down_period
        self.commsReliability = reliability
        synth.simulation.sim.inject_event_delta(0, self.tick_comms_up_down, self)  # Immediately

    def tick_comms_up_down(self, _):
        if isinstance(self.commsReliability, (int, float)):  # Simple probability
            self.commsOK = self.commsReliability > random.random()
        else:  # Probability spec, i.e. varies with time
            rel_time = synth.simulation.sim.get_time() - synth.simulation.sim.startTime
            prob = synth.simulation.helpers.timewave.interp(self.commsReliability, rel_time)
            if self.property_exists("rssi"):  # Now affect comms according to RSSI
                rssi = self.get_property("rssi")
                radio_goodness = 1.0 - (rssi - GOOD_RSSI) / (BAD_RSSI - GOOD_RSSI)  # Map to 0..1
                radio_goodness = 1.0 - math.pow((1.0 - radio_goodness), 4)  # Skew heavily towards "good"
                prob *= radio_goodness
            self.commsOK = prob > random.random()

        delta_time = random.expovariate(1 / self.commsUpDownPeriod)
        delta_time = min(delta_time, self.commsUpDownPeriod * 100)  # Limit long tail
        synth.simulation.sim.inject_event_delta(delta_time, self.tick_comms_up_down, self)

    def do_comms(self, properties):
        if self.commsOK:
            update_callback(properties)
            log_entry(properties)

    def get_property(self, prop_name):
        return self.properties[prop_name]

    def property_exists(self, prop_name):
        return prop_name in self.properties

    def set_property(self, prop_name, value):
        new_props = {prop_name: value, "$ts": synth.simulation.sim.get_time_1000(),
                     "$id": self.properties["$id"]}
        self.properties.update(new_props)
        self.do_comms(new_props)

    def set_properties(self, new_props):
        self.properties.update(new_props)
        self.properties.update({"$ts": synth.simulation.sim.get_time_1000(), "$id": self.properties["$id"]})
        self.do_comms(new_props)

    def tick_hourly(self, _):
        if self.get_property("battery") > 0:
            self.set_property("light", solar_math.sun_bright(synth.simulation.sim.get_time(),
                                                             (float(Device.get_property(self, "longitude")),
                                                              float(Device.get_property(self, "latitude")))
                                                             ))
            synth.simulation.sim.inject_event_delta(synth.simulation.sim.hours(1), self.tick_hourly, self)

# Model for comms unreliability
# -----------------------------
# Two variables define comms (un)reliability:
# a) up/down period: (secs) The typical period over which comms might change between working and failed state.
#    We use an exponential distribution with this value as the mean.
# b) reliability: (0..1) The chance of comms working at any moment in time
# The comms state is then driven independently of other actions.
# 
# Chance of comms failing at any moment is [0..1]
# Python function random.expovariate(lambda) returns values from 0 to infinity, with most common values in a hump in
# the middle such that that mean value is 1.0/<lambda>
